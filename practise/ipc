

#include<string>
#include<thread>
#include<algorithm>
#include<unistd.h>
#include<cstring>
#include<iostream>
#include<vector>
#include<climits>

using namespace std;

class labTest {
private:
	string labTestId;
	int result;

public:
	labTest(string labTestId, int result):labTestId(labTestId),result(result) {}

	int getresult() {
		return result;
	}
};

void findSum(const std::vector<int>& vec, int start, int end, int& sum) {
	for(int i = start; i < end; i++) {
		sum += vec[i];
	}
}

void client(vector<labTest>& vec, int& write_end_fd1, int& read_end_fd2) {
	int size = vec.size();
	write(write_end_fd1, &size, sizeof(size));
	int buffer[size];
	for(int i = 0; i < vec.size(); i++) {
		buffer[i] = vec[i].getresult();
	}
	write(write_end_fd1, buffer, sizeof(buffer));

	cout << "client : ";
	for(int i = 0; i < size; i++) {
		cout << buffer[i] << " ";
	}
	cout << endl;
	close(write_end_fd1);
	sleep(2);

	int sum = 0,sum1,sum2;
	read(read_end_fd2, &sum,&sum1,&sum2, sizeof(int),sizeof(int),sizeof(int));

	cout << "total sum : " << sum <<":"<<sum1<<":"<<sum2<< endl;
	close(read_end_fd2);
}

void server(int& read_end_fd1, int& write_end_fd2) {
	sleep(1);

	int size;
	read(read_end_fd1, &size, sizeof(size));

	int a[size];
	read(read_end_fd1, a, sizeof(int) * size);

	cout << "server ::" << endl;
	close(read_end_fd1);

	int s = sizeof(a) / sizeof(a[0]);
	std::vector<int> vec(a, a + s);

	int sum1 = 0, sum2 = 0;
	int mid = size / 2;

	thread t1(findSum, vec, 0, mid, ref(sum1));
	thread t2(findSum, vec, mid, size, ref(sum2)); // Changed mid+1 to mid

	t1.join();
	t2.join();
	int totalSum = sum1 + sum2;
	write(write_end_fd2, &totalSum,&sum1,&sum2, sizeof(totalSum),sizeof(sum1),sizeof(sum2));
	cout << "sum sent : " << totalSum << endl;
	close(write_end_fd2);
}

int main() {
	vector<labTest> vec;
	vec.emplace_back("vm1", 2);
	vec.emplace_back("vm2", 5);
	vec.emplace_back("vm3", 6);
	vec.emplace_back("vm4", 3);
	vec.emplace_back("vm5", 1);

	int pipe_fd1[2];
	int pipe_fd2[2];
	if(pipe(pipe_fd1) || pipe(pipe_fd2) == -1) {
		perror("pipe");
		cout << "pipe not created" << endl;
		return 1;
	}

	pid_t pid;
	{
		pid = fork();
		if(pid == 0) {
			close(pipe_fd1[0]);
			client(vec, pipe_fd1[1], pipe_fd2[0]);
			return 0;
		}
	}

	{	pid = fork();
		if(pid == 0) {
			close(pipe_fd1[1]);
			server(pipe_fd1[0], pipe_fd2[1]);
			return 0;
		}
	}

	sleep(3);
	return 0;
}
