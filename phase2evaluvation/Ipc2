#include <iostream>
#include <vector>
#include <climits>
#include <string>
#include <thread>
#include <future>
#include <algorithm>

using namespace std;

class labTest {
private:
    string labTestId;
    double result;

public:
    labTest(string labTestId, double result) : labTestId(labTestId), result(result) {}

    double getresult() const {
        return result;
    }
};

void calculatePartialSum(const vector<double>& data, int start, int end, double& partialSum) {
    partialSum = 0;
    for (int i = start; i < end; ++i) {
        partialSum += data[i];
    }
}

void client(vector<labTest>& vec, promise<vector<double>>& dataPromise, future<double>& sumFuture) {
    // Prepare data to send to the server
    vector<double> buffer;
    for (const auto& test : vec) {
        buffer.push_back(test.getresult());
    }
    cout << "Client: Sending data to server...\n";
    dataPromise.set_value(buffer);

    // Wait for the result from the server
    double sum = sumFuture.get();
    cout << "Client: Received total sum from server: " << sum << endl;
}

void server(future<vector<double>>& dataFuture, promise<double>& sumPromise) {
    // Receive data from the client
    vector<double> data = dataFuture.get();
    cout << "Server: Received data from client...\n";

    double firstHalfSum = 0, secondHalfSum = 0;

    // Calculate partial sums in separate threads
    thread t1(calculatePartialSum, cref(data), 0, data.size() / 2, ref(firstHalfSum));
    thread t2(calculatePartialSum, cref(data), data.size() / 2, data.size(), ref(secondHalfSum));

    t1.join();
    t2.join();

    double totalSum = firstHalfSum + secondHalfSum;
    cout << "Server: Calculated total sum: " << totalSum << endl;

    // Send the result back to the client
    sumPromise.set_value(totalSum);
}

int main() {
    vector<labTest> vec;
    vec.emplace_back("am1", 2.45);
    vec.emplace_back("am2", 5.34);
    vec.emplace_back("am3", 6.56);
    vec.emplace_back("am4", 3.43);
    vec.emplace_back("am5", 1.23);

    // Create promises and futures for communication
    promise<vector<double>> dataPromise;
    future<vector<double>> dataFuture = dataPromise.get_future();

    promise<double> sumPromise;
    future<double> sumFuture = sumPromise.get_future();

    // Start client and server threads
    thread clientThread(client, ref(vec), ref(dataPromise), ref(sumFuture));
    thread serverThread(server, ref(dataFuture), ref(sumPromise));

    clientThread.join();
    serverThread.join();

    return 0;
}
